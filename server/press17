local args = {...}

-- Core Settings
PROTOCOL = "press"

-- Grid Settings
GRID_SIZE = 8
GRID_WIDTH = 2
GRID_HEIGHT = 2

-- Timeout Settings
HANDSHAKE_TIMEOUT = 2
PREPARE_TIMEOUT = 25

local modem = peripheral.find("modem", rednet.open)
local turtles = {}

function reload_turtles()
    local count = 0
    local all = true
    for y = 0, GRID_HEIGHT - 1 do
        for x = 0, GRID_WIDTH - 1 do
            local name = "robot" .. string.char(65 + x) .. (y + 1)
            local id = rednet.lookup(PROTOCOL, name)
            if turtles[id] then
                turtles[id].found = id ~= nil
                turtles[id].ack = turtles[id].ack and id ~= nil
                turtles[id].selected = false
                turtles[id].ready = false

                if turtles[id].found then
                    count = count + 1
                else
                    print("[Error] Bot " .. name .. " not found!")
                    all = false
                end
            else
                if id then
                    turtles[id] = {name = name, ack = false, ready = false, x = x, y = y, found = id ~= nil, selected = false}
                    count = count + 1
                else
                    print("[Error] Bot " .. name .. " not found!")
                    all = false
                end
            end
        end
    end

    print("[Info] Found " .. count .. " turtles.")
    print("[Info] Waiting for handshakes...")
    
    function send()
        for id, bot in pairs(turtles) do
            rednet.send(id, "handshake", PROTOCOL)
            sleep(0.01)
        end
    end

    local ready = 0
    
    function receive()
        local x, y = term.getCursorPos()
        term.setCursorPos(x, y)
        print("[Info] Number of handshaken turtles: " .. ready .. "/" .. count)

        local start = os.clock()
        while os.clock() - start < HANDSHAKE_TIMEOUT and ready < count do
            local id, msg, proto = rednet.receive(PROTOCOL, HANDSHAKE_TIMEOUT - (os.clock() - start))
            if id and msg == "ack" then
                turtles[id].ack = true
                ready = ready + 1
                start = os.clock()
                term.setCursorPos(x, y)
                print("[Info] Number of handshaken turtles: " .. ready .. "/" .. count)
            end
        end
    end

    parallel.waitForAll(send, receive)
    
    for id, bot in pairs(turtles) do
        if not bot.ack then
            print("[Error] Bot " .. bot.name .. " did not handshake!") 
            all = false
        end
    end

    return all
end

function wait_for_done(timeout)
    -- wait for tutles to show the done message
    local count = 0
    local ready = 0

    print("[Info] Waiting for turtles to finish...")
    for id, bot in pairs(turtles) do
        count = count + 1
        bot.done = false
    end

    local x, y = term.getCursorPos()
    term.setCursorPos(x, y)
    print("[Info] Number of done turtles: " .. ready .. "/" .. count)

    local start = os.clock()
    while os.clock() - start < timeout and ready < count do
        local id, msg, proto = rednet.receive(PROTOCOL, timeout - (os.clock() - start))
        if id and msg:sub(1, 4) == "done" then
            ready = ready + 1
            term.setCursorPos(x, y)
            turtles[id].done = true
            print("[Info] Number of done turtles: " .. ready .. "/" .. count)
        end
    end

    for id, bot in pairs(turtles) do
        if not bot.done then
            print("[Error] Turtle " .. bot.name .. " did not finish in time!")
            valid = false
        end
    end

    if ready == count then
        print("[Info] All turtles finished!")
    else
        print("[Error] Not all turtles finished!")
    end
end

function get_grid(url)
    local response = http.get(url)
    if not response then
        print("[Error] Invalid URL")
    end
    
    local raw_data = response.readAll()
    response.close()
    
    local grid = {}
    for line in raw_data:gmatch("[^\r\n]+") do
        local row = {}
        for number in line:gmatch("%d+") do
            table.insert(row, tonumber(number))
        end
        if #row ~= GRID_WIDTH * GRID_SIZE then
            --print("[Error] Line " .. (#grid + 1) .. " has a wrong size!")
            --return
        end
        table.insert(grid, row)
    end
    
    if #grid ~= GRID_HEIGHT * GRID_SIZE then
        --print("[Error] Invalid row count")
        --return
    end

    return grid
end

term.clear()

if args[1] == "clear" then
    if not reload_turtles() then
        print("[Error] Initlization shutdown!")
        return
    end
    print("[Info] Clear mode activated!")
    print("[Info] Clearing...")

    for id, bot in pairs(turtles) do
        rednet.send(id, "clear", PROTOCOL)
    end
    
    wait_for_done(240)
elseif args[i] and args[1]:sub(1, 5) == "build" then
    local url = args[2]

    if not url then
        print("[Error] No URL provided!")
        return
    end

    if not reload_turtles() then
        print("[Error] Initlization shutdown!")
        return
    end
    
    local grid = get_grid(url)

    print("[Info] Sending data to turtles...")
    for id, bot in pairs(turtles) do
        local grid_part = ""
        for y = 0, GRID_SIZE - 1 do
            local row = {}
            for x = 0, GRID_SIZE - 1 do
                local index_y = bot.y * GRID_SIZE + y
                local index_x = bot.x * GRID_SIZE + x
                grid_part = grid_part .. grid[index_y + 1][index_x + 1] .. " "
            end
            grid_part = grid_part .. "\n"
        end

        rednet.send(id, "build " .. grid_part, PROTOCOL)
    end
    wait_for_done(240)
elseif args[1] == "update" then
    local url = args[2]
    if not url then
        print("[Error] No URL provided!")
        return
    end

    if not reload_turtles() then
        print("[Error] Initlization shutdown!")
        return
    end
    
    local count = 0
    local ready = 0

    for id, bot in pairs(turtles) do
        count = count + 1
    end

    local x, y = term.getCursorPos()
    term.setCursorPos(x, y)
    print("[Info] Number of ready turtles: " .. ready .. "/" .. count)

    for id, bot in pairs(turtles) do
        ready = ready + 1
        term.setCursorPos(x, y)
        rednet.send(id, "update " .. url, PROTOCOL)
        print("[Info] Number of ready turtles: " .. ready .. "/" .. count)
    end

    print("[Info] Update sent to turtles!")
    print("[Info] Wait for the turtles to finish!")
elseif args[1] == "pick" then
    if not reload_turtles() then
        print("[Error] Initlization shutdown!")
        return
    end

    local slot = tonumber(args[2])
    if not slot then
        print("[Error] No slot provided!")
        return
    end

    print("[Info] Picking up items...")
    for id, bot in pairs(turtles) do
        rednet.send(id, "pick " .. slot, PROTOCOL)
    end
    wait_for_done(240)
elseif args[1] == "empty" then
    if not reload_turtles() then
        print("[Error] Initlization shutdown!")
        return
    end
    print("[Info] Emptying items...")
    for id, bot in pairs(turtles) do
        rednet.send(id, "empty", PROTOCOL)
    end
    wait_for_done(240)
elseif args[1] == "cancel" then
    print("[Info] Cancelling...")
    for y = 0, GRID_HEIGHT - 1 do
        for x = 0, GRID_WIDTH - 1 do
            local name = "robot" .. string.char(65 + x) .. (y + 1)
            local id = rednet.lookup(PROTOCOL, name)
            if id then
                rednet.send(id, "cancel", PROTOCOL)
            end
        end
    end
else
    print("[Error] Invalid mode! Use 'clear', 'build', 'update', 'pick', 'empty' or 'cancel'.")
    return
end
