local args = {...}

-- Core Settings
PROTOCOL = "press"

-- Grid Settings
GRID_SIZE = 8
GRID_WIDTH = 16
GRID_HEIGHT = 16

-- Timeout Settings
HANDSHAKE_TIMEOUT = 2
PREPARE_TIMEOUT = 25

local modem = peripheral.find("modem", rednet.open)
local turtles = {}

-- wrap a monitor to display the turtle states
local monitor = peripheral.find("monitor")
if monitor then
    --monitor.setTextScale(1)
    monitor.setTextColor(colors.white)
    monitor.setBackgroundColor(colors.black)
    monitor.clear()
end

function get_turtle(x, y)
    for id, bot in pairs(turtles) do
        if bot.x == x and bot.y == y then
            return bot
        end
    end
    return nil
end

function refresh_screen()

    function draw_grid(pos_x, pos_y)
        monitor.setBackgroundColor(colors.black)
        monitor.setTextColor(colors.white)
        monitor.clear()
        monitor.setCursorPos(pos_x + 2, pos_y)

        for x = 0, GRID_WIDTH - 1 do
            monitor.write(string.char(65 + x) .. " ")
        end

        for y = 0, GRID_HEIGHT - 1 do
            monitor.setCursorPos(pos_x, pos_y + y * 2 + 2)
            monitor.write(tostring(y + 1) .. " ")

            -- draw the grid
            for x = 0, GRID_WIDTH - 1 do
                monitor.setCursorPos(pos_x + 2 + x * 2, pos_y + y * 2 + 2)
                turtle = get_turtle(x, y)
                if turtle then
                    if turtle.ack then
                        monitor.setTextColor(colors.green)
                    else
                        monitor.setTextColor(colors.red)
                    end
                else
                    monitor.setTextColor(colors.white)
                end

                monitor.write("O")
            end
        end
    end

    draw_grid(4, 4)
end

function reload_turtles()
    print("[Info] Reloading turtles...")
    local count = 0
    local all = true
    for y = 0, GRID_HEIGHT - 1 do
        for x = 0, GRID_WIDTH - 1 do
            local name = "robot" .. string.char(65 + x) .. (y + 1)
            local id = rednet.lookup(PROTOCOL, name)
            if turtles[id] then
                turtles[id].found = id ~= nil
                turtles[id].ack = turtles[id].ack and id ~= nil
                turtles[id].selected = false
                turtles[id].ready = false

                if turtles[id].found then
                    count = count + 1
                else
                    print("[Error] Bot " .. name .. " not found!")
                    all = false
                end
            else
                if id then
                    turtles[id] = {name = name, ack = false, ready = false, x = x, y = y, found = id ~= nil, selected = false}
                    count = count + 1
                else
                    print("[Error] Bot " .. name .. " not found!")
                    all = false
                end
            end

            refresh_screen()
        end
    end

    print("[Info] Found " .. count .. " turtles.")
    print("[Info] Waiting for handshakes...")
    
    function send()
        for id, bot in pairs(turtles) do
            rednet.send(id, "handshake", PROTOCOL)
            sleep(0.01)
        end
    end

    local ready = 0
    
    function receive()
        local x, y = term.getCursorPos()
        term.setCursorPos(x, y)
        print("[Info] Number of handshaken turtles: " .. ready .. "/" .. count)

        local start = os.clock()
        while os.clock() - start < HANDSHAKE_TIMEOUT and ready < count do
            local id, msg, proto = rednet.receive(PROTOCOL, HANDSHAKE_TIMEOUT - (os.clock() - start))
            if id and msg == "ack" then
                turtles[id].ack = true
                ready = ready + 1
                start = os.clock()
                term.setCursorPos(x, y)
                print("[Info] Number of handshaken turtles: " .. ready .. "/" .. count)
                refresh_screen()
            end
        end

        term.write("\n")
    end 

    parallel.waitForAll(send, receive)
    
    for id, bot in pairs(turtles) do
        if not bot.ack then
            print("[Error] Bot " .. bot.name .. " did not handshake!") 
            all = false
        end
    end

    refresh_screen()
    return all
end

function wait_for_done(timeout)
    -- wait for tutles to show the done message
    local count = 0
    local ready = 0

    print("[Info] Waiting for turtles to finish...")
    for id, bot in pairs(turtles) do
        count = count + 1
        bot.done = false
    end

    local x, y = term.getCursorPos()
    term.setCursorPos(x, y)
    print("[Info] Number of done turtles: " .. ready .. "/" .. count)

    local start = os.clock()
    while os.clock() - start < timeout and ready < count do
        local id, msg, proto = rednet.receive(PROTOCOL, timeout - (os.clock() - start))
        if id and msg:sub(1, 4) == "done" then
            ready = ready + 1

            turtles[id].done = true
            term.setCursorPos(x, y)  
            print("[Info] Number of done turtles: " .. ready .. "/" .. count)
        end
    end

    for id, bot in pairs(turtles) do
        if not bot.done then
            print("[Error] Turtle " .. bot.name .. " did not finish in time!")
            valid = false
        end
    end

    if ready == count then
        print("[Info] All turtles finished!")
    else
        print("[Error] Not all turtles finished!")
    end
end

function get_grid(url)
    local response = http.get(url)
    if not response then
        print("[Error] Invalid URL")
    end
    
    local raw_data = response.readAll()
    response.close()
    
    local grid = {}
    for line in raw_data:gmatch("[^\r\n]+") do
        local row = {}
        for number in line:gmatch("%d+") do
            table.insert(row, tonumber(number))
        end
        if #row ~= GRID_WIDTH * GRID_SIZE then
            --print("[Error] Line " .. (#grid + 1) .. " has a wrong size!")
            --return
        end
        table.insert(grid, row)
    end
    
    if #grid ~= GRID_HEIGHT * GRID_SIZE then
        --print("[Error] Invalid row count")
        --return
    end

    return grid
end

reload_turtles()
return
