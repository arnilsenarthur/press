local args = {...}

-- Core Settings
PROTOCOL = "press"

-- Grid Settings
GRID_SIZE = 8
GRID_WIDTH = 16
GRID_HEIGHT = 16

-- Timeout Settings
HANDSHAKE_TIMEOUT = 2
PREPARE_TIMEOUT = 25

local modem = peripheral.find("modem", rednet.open)
local turtles = {}
local screen = {widgets = {}}
local speaker = peripheral.find("speaker")

-- wrap a monitor to display the turtle states
local monitor = peripheral.find("monitor")
if monitor then
    --monitor.setTextScale(1)
    monitor.setTextColor(colors.white)
    monitor.setBackgroundColor(colors.black)
    monitor.clear()
end

function get_turtle(x, y)
    for id, bot in pairs(turtles) do
        if bot.x == x and bot.y == y then
            return bot
        end
    end
    return nil
end

function refresh_screen()
    function draw_grid(pos_x, pos_y)
        -- Clear widgets
        screen.widgets = {}

        monitor.setBackgroundColor(colors.black)
        monitor.setTextColor(colors.lightGray)
        monitor.clear()
        monitor.setCursorPos(pos_x, pos_y)

        monitor.write("X ")
        table.insert(screen.widgets, {x = pos_x, y = pos_y, width = 1, height = 1, id = "all"})

        for x = 0, GRID_WIDTH - 1 do
            monitor.write(string.char(65 + x) .. " ")
            table.insert(screen.widgets, {x = pos_x + 2 + x * 2, y = pos_y, width = 1, height = 1, id = "column_" .. x})
        end

        for y = 0, GRID_HEIGHT - 1 do
            monitor.setTextColor(colors.lightGray)
            
            if y > 8 then
                monitor.setCursorPos(pos_x - 1, pos_y + y * 2 + 2)
            else
                monitor.setCursorPos(pos_x, pos_y + y * 2 + 2)
            end

            monitor.write(tostring(y + 1) .. " ")
            table.insert(screen.widgets, {x = pos_x, y = pos_y + y * 2 + 2, width = 1, height = 1, id = "row_" .. y})

            -- draw the grid
            for x = 0, GRID_WIDTH - 1 do
                monitor.setCursorPos(pos_x + 2 + x * 2, pos_y + y * 2 + 2)
                turtle = get_turtle(x, y)
                if turtle then
                    if turtle.selected then
                        monitor.setBackgroundColor(colors.gray)
                    else
                        monitor.setBackgroundColor(colors.black)
                    end

                    if turtle.ack then
                        monitor.setTextColor(colors.green)
                    else
                        monitor.setTextColor(colors.red)
                    end
                    monitor.write("O")
                else
                    monitor.setBackgroundColor(colors.black)
                    monitor.setTextColor(colors.white)
                    monitor.write("?")
                end          
                
                table.insert(screen.widgets, {x = pos_x + 2 + x * 2, y = pos_y + y * 2 + 2, width = 1, height = 1, id = "grid_" .. x .. "_" .. y})
            end

            monitor.setBackgroundColor(colors.black)
        end
    end

    draw_grid(4, 4)
end

function reload_turtles()
    print("[Info] Reloading turtles...")
    local count = 0
    local all = true
    for y = 0, GRID_HEIGHT - 1 do
        for x = 0, GRID_WIDTH - 1 do
            local name = "robot" .. string.char(65 + x) .. (y + 1)
            local id = rednet.lookup(PROTOCOL, name)
            if turtles[id] then
                turtles[id].found = id ~= nil
                turtles[id].ack =  false
                turtles[id].ready = false

                if turtles[id].found then
                    count = count + 1
                else
                    print("[Error] Bot " .. name .. " not found!")
                    all = false
                end
            else
                if id then
                    turtles[id] = {name = name, ack = false, ready = false, x = x, y = y, found = id ~= nil, selected = true}
                    count = count + 1
                else
                    print("[Error] Bot " .. name .. " not found!")
                    all = false
                end
            end

            refresh_screen()
        end
    end

    print("[Info] Found " .. count .. " turtles.")
    print("[Info] Waiting for handshakes...")
    
    function send()
        for id, bot in pairs(turtles) do
            rednet.send(id, "handshake", PROTOCOL)
            sleep(0.01)
        end
    end

    local ready = 0
    
    function receive()
        local x, y = term.getCursorPos()
        term.setCursorPos(x, y)
        print("[Info] Number of handshaken turtles: " .. ready .. "/" .. count)

        local start = os.clock()
        while os.clock() - start < HANDSHAKE_TIMEOUT and ready < count do
            local id, msg, proto = rednet.receive(PROTOCOL, HANDSHAKE_TIMEOUT - (os.clock() - start))
            if id and msg == "ack" then
                turtles[id].ack = true
                ready = ready + 1
                start = os.clock()
                term.setCursorPos(x, y)
                print("[Info] Number of handshaken turtles: " .. ready .. "/" .. count)
                refresh_screen()
            end
        end

        term.write("\n")
    end 

    parallel.waitForAll(send, receive)
    
    for id, bot in pairs(turtles) do
        if not bot.ack then
            print("[Error] Bot " .. bot.name .. " did not handshake!") 
            all = false
        end
    end

    refresh_screen()
    return all
end

function wait_for_done(timeout)
    -- wait for tutles to show the done message
    local count = 0
    local ready = 0

    print("[Info] Waiting for turtles to finish...")
    for id, bot in pairs(turtles) do
        count = count + 1
        bot.done = false
    end

    local x, y = term.getCursorPos()
    term.setCursorPos(x, y)
    print("[Info] Number of done turtles: " .. ready .. "/" .. count)

    local start = os.clock()
    while os.clock() - start < timeout and ready < count do
        local id, msg, proto = rednet.receive(PROTOCOL, timeout - (os.clock() - start))
        if id and msg:sub(1, 4) == "done" then
            ready = ready + 1

            turtles[id].done = true
            term.setCursorPos(x, y)  
            print("[Info] Number of done turtles: " .. ready .. "/" .. count)
        end
    end

    for id, bot in pairs(turtles) do
        if not bot.done then
            print("[Error] Turtle " .. bot.name .. " did not finish in time!")
            valid = false
        end
    end

    if ready == count then
        print("[Info] All turtles finished!")
    else
        print("[Error] Not all turtles finished!")
    end
end

function get_grid(url)
    local response = http.get(url)
    if not response then
        print("[Error] Invalid URL")
    end
    
    local raw_data = response.readAll()
    response.close()
    
    local grid = {}
    for line in raw_data:gmatch("[^\r\n]+") do
        local row = {}
        for number in line:gmatch("%d+") do
            table.insert(row, tonumber(number))
        end
        if #row ~= GRID_WIDTH * GRID_SIZE then
            --print("[Error] Line " .. (#grid + 1) .. " has a wrong size!")
            --return
        end
        table.insert(grid, row)
    end
    
    if #grid ~= GRID_HEIGHT * GRID_SIZE then
        --print("[Error] Invalid row count")
        --return
    end

    return grid
end

reload_turtles()

-- Handle clicks on the monitor
while true do
    local event, side, x, y = os.pullEvent("monitor_touch")
    if event == "monitor_touch" then
        for _, widget in ipairs(screen.widgets) do
            if x >= widget.x and x <= widget.x + widget.width - 1 and y >= widget.y and y <= widget.y + widget.height - 1 then
                speaker.playSound("ui.button.click")
                if widget.id:sub(1, 5) == "grid_" then
                    local gridX, gridY = widget.id:match("grid_(%d+)_(%d+)")
                    gridX = tonumber(gridX)
                    gridY = tonumber(gridY)
                    local turtle = get_turtle(gridX, gridY)
                    if turtle then
                        turtle.selected = not turtle.selected
                    end
                    refresh_screen()
                elseif widget.id:sub(1, 6) == "column_" then
                    local column = tonumber(widget.id:sub(7))
                    local turtle = get_turtle(column, 0)
                    local new_value = not turtle.selected
                    for y = 0, GRID_HEIGHT - 1 do
                        local turtle = get_turtle(column, y)
                        if turtle then
                            turtle.selected = new_value
                            if new_value then
                                print("[Info] Turtle " .. turtle.name .. " selected!")
                            else
                                print("[Info] Turtle " .. turtle.name .. " unselected!")
                            end
                        end
                    end
                    refresh_screen()
                elseif widget.id:sub(1, 4) == "row_" then
                    local row = tonumber(widget.id:sub(5))
                    local turtle = get_turtle(0, row)
                    local new_value = not turtle.selected
                    for x = 0, GRID_WIDTH - 1 do
                        local turtle = get_turtle(x, row)
                        if turtle then
                            turtle.selected = new_value
                        end
                    end
                    refresh_screen()
                elseif widget.id == "all" then
                    print("[Info] All turtles clicked!")
                    -- use the first turtle as a reference
                    local turtle = get_turtle(0, 0)
                    local new_value = not turtle.selected

                    for id, bot in pairs(turtles) do
                        bot.selected = new_value
                    end
                    refresh_screen()
                end

                break
            end
        end
        print("[Info] Monitor touched at " .. x .. ", " .. y)
    end
end

return
